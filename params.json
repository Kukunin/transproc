{"name":"Transproc","tagline":"Transform Ruby objects in functional style","body":"[gem]: https://rubygems.org/gems/transproc\r\n[travis]: https://travis-ci.org/solnic/transproc\r\n[gemnasium]: https://gemnasium.com/solnic/transproc\r\n[codeclimate]: https://codeclimate.com/github/solnic/transproc\r\n[coveralls]: https://coveralls.io/r/solnic/transproc\r\n[inchpages]: http://inch-ci.org/github/solnic/transproc\r\n\r\n# Transproc [![Join the chat at https://gitter.im/solnic/transproc](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/solnic/transproc)\r\n\r\n[![Gem Version](https://badge.fury.io/rb/transproc.svg)][gem]\r\n[![Build Status](https://travis-ci.org/solnic/transproc.svg?branch=master)][travis]\r\n[![Dependency Status](https://gemnasium.com/solnic/transproc.svg)][gemnasium]\r\n[![Code Climate](https://codeclimate.com/github/solnic/transproc/badges/gpa.svg)][codeclimate]\r\n[![Test Coverage](https://codeclimate.com/github/solnic/transproc/badges/coverage.svg)][codeclimate]\r\n[![Inline docs](http://inch-ci.org/github/solnic/transproc.svg?branch=master)][inchpages]\r\n\r\nTransproc is a small library that allows you to compose methods into a functional pipeline using left-to-right function composition. It works like `|>` in Elixir or `>>` in F#.\r\n\r\nIt's currently used as the data mapping backend in [Ruby Object Mapper](http://rom-rb.org).\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'transproc'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install transproc\r\n\r\n## Usage\r\n\r\n``` ruby\r\nrequire 'json'\r\nrequire 'transproc/all'\r\nrequire 'inflecto'\r\n\r\n# create your own local registry for transformation functions\r\nmodule Functions\r\n  extend Transproc::Registry\r\nend\r\n\r\n# import necessary functions from external modules\r\nmodule Functions\r\n  # all transformations available in the imported module\r\n  import Transproc::HashTransforations\r\n  import Transproc::ArrayTransformations\r\n\r\n  # only specific transformation (renamed into the desired local name)\r\n  import :camelize, from: Inflecto, as: :camel_case\r\nend\r\n\r\ndef t(*args)\r\n  Functions[*args]\r\nend\r\n\r\n# use imported transformation\r\ntransformation = t(:camel_case)\r\n\r\ntransformation.call 'i_am_a_camel'\r\n# => \"IAmACamel\"\r\n\r\ntransformation = t(:map_array, t(:symbolize_keys) >> t(:rename_keys, user_name: :user))\r\ntransformation >>= t(:wrap, :address, [:city, :street, :zipcode])\r\n\r\ntransformation.call(\r\n  [\r\n    { 'user_name' => 'Jane',\r\n      'city' => 'NYC',\r\n      'street' => 'Street 1',\r\n      'zipcode' => '123' }\r\n  ]\r\n)\r\n# => [{:user=>\"Jane\", :address=>{:city=>\"NYC\", :street=>\"Street 1\", :zipcode=>\"123\"}}]\r\n\r\n# define your own composable transformation easily\r\ntransformation = t(-> v { JSON.dump(v) })\r\n\r\ntransformation.call(name: 'Jane')\r\n# => \"{\\\"name\\\":\\\"Jane\\\"}\"\r\n\r\n# ...or add it to registered functions via singleton method of the registry\r\nmodule Functions\r\n  # ...\r\n\r\n  def self.load_json(v)\r\n    JSON.load(v)\r\n  end\r\nend\r\n\r\ntransformation = t(:load_json) >> t(:map_array, t(:symbolize_keys))\r\n\r\ntransformation.call('[{\"name\":\"Jane\"}]')\r\n# => [{ :name => \"Jane\" }]\r\n```\r\n\r\n## Credits\r\n\r\nThis project is inspired by the work of following people:\r\n\r\n* [Markus Schirp](https://github.com/mbj) and [morpher](https://github.com/mbj/morpher) project\r\n* [Josep M. Bach](https://github.com/txus) and [kleisli](https://github.com/txus/kleisli) project\r\n\r\n## Contributing\r\n\r\n1. Fork it ( https://github.com/solnic/transproc/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create a new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}